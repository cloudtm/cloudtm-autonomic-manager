/*************************************************************************/
/*									 */
/*	Source code for use with Cubist Release 2.07			 */
/*	--------------------------------------------			 */
/*		   Copyright RuleQuest Research 2010			 */
/*									 */
/*	This code is provided "as is" without warranty of any kind,	 */
/*	either express or implied.  All use is at your own risk.	 */
/*									 */
/*	WARNING: This code is not intended for use with models		 */
/*	generated by earlier Cubist releases.				 */
/*									 */
/*************************************************************************/


/*************************************************************************/
/*									 */
/*	Sample program to demonstrate the use of Cubist models		 */
/*	------------------------------------------------------		 */
/*									 */
/*	Compilation:							 */
/*									 */
/*	    Linux: use an ANSI C compiler such as gcc and include	 */
/*		   the math library and pthreads library, e.g.		 */
/*			gcc -O3 sample.c -lm -lpthread			 */
/*									 */
/*	    Windows: compile as a multithreaded console application	 */
/*		   with symbol "WIN32" and "_CONSOLE" defined.		 */
/*									 */
/*	The options for this program are:				 */
/*									 */
/*	    -f <filestem>   specify the application name		 */
/*	    -p		    print the cubist model			 */
/*	    -e		    show estimated error bounds for each case	 */
/*	    -i		    show neighbors (when the Cubist model	 */
/*			    uses instances as well as rules)		 */
/*									 */
/*									 */
/*	The program expects to find the following files:		 */
/*									 */
/*	    <filestem>.names (the application names file)		 */
/*	    <filestem>.model (the model file generated by Cubist)	 */
/*	    <filestem>.cases (with the same format as a .data file) 	 */
/*	    <filestem>.data  (the training data, if the Cubist model	 */
/*			      uses instances as well as rules)		 */
/*									 */
/*	Please note: the names file and data file (if required)		 */
/*	must be exactly as they were when the model was generated.	 */
/*									 */
/*	For each case in <filestem.cases>, the program prints the	 */
/*	target value and then the value predicted by the model.  If	 */
/*	selected, error bounds of the form "+- E" are nominally set	 */
/*	at 95%, so that the absolute error should be less than E for	 */
/*	95% of cases.  These bounds are estimated heuristically, and	 */
/*	a summary showing the actual percentage of cases within the	 */
/*	printed bounds gives a more accurate assessment of the real	 */
/*	percentage.							 */
/*									 */
/*	An asterisk ("*") appearing at the start of the output for a	 */
/*	case is a warning: at least one attribute used in the model	 */
/*	has a value outside the range observed in the training data.	 */
/*	The predicted value for this case is therefore suspect.		 */
/*									 */
/*	Revised March 2010						 */
/*									 */
/*************************************************************************/


#include "defns.h"
#include "global.c"
#include "hooks.c"

#if ! defined WIN32 && ! defined _CONSOLE
#include <sys/unistd.h>
#include <sys/time.h>
#include <sys/resource.h>
#ifndef _SC_NPROCESSORS_CONF
#define _SC_NPROCESSORS_CONF _SC_NPROC_CONF
#endif
#endif


int		Offset=30, CaseID=0;
Boolean		PreviewModel=false, ShowErrBounds=false, ShowNN=false;
Thread		*Thr=Nil;
int		NThr;
NNEnvRec	*ThrEnv=Nil;
DataRec		*Block=Nil;
float		*Err=Nil;
Flag		*Start=Nil,
		*Done=Nil;
String		*Label=Nil;


/*************************************************************************/
/*									 */
/*	Main                                                             */
/*									 */
/*************************************************************************/


int main(int Argc, char *Argv[])
/*  ----  */
{
    FILE		*F;
    DataRec		DVec;
    int			o, m, t, InBounds=0, Known=0, AtEOF=0, IValsBase=0;
    float		Low, High;
    extern String	OptArg, Option, PropVal;
    char		Msg[100];
    CaseNo		i;

    /*  Process options  */

    while ( (o = ProcessOption(Argc, Argv, "f+pei")) )
    {
	switch (o)
	{
	case 'f':   FileStem = OptArg;
		    break;
	case 'p':   PreviewModel = true;
		    break;
	case 'e':   ShowErrBounds = true;
		    break;
	case 'i':   ShowNN = true;
		    break;
	case '?':   printf("    **Unrecognised option %s\n", Option);
		    exit(1);
	}
    }

    /*  Find the number of cores/processors and set the number of
	concurrent threads.  The multiple 5 can be changed if it
	performs poorly on your application.  */

    FindNCPU();
    NThr = 5 * NCPU;

    /*  Read information on attribute names and values  */

    if ( ! (F = GetFile(".names", "r")) ) Error(0, Fn, "");
    GetNames(F);

    /*  Read the model file that defines the ruleset and sets values
	for various global variables such as USEINSTANCES  */

    CubistModel = GetCommittee(".model");

    if ( PreviewModel )
    {
	/*  Display the rulesets  */

	ForEach(m, 0, MEMBERS-1)
	{
	    if ( MEMBERS > 1 )
	    {
		sprintf(Msg, "Model %d:", m+1);
	    }
	    else
	    {
		sprintf(Msg, "Model:");
	    }
	    PrintRules(CubistModel[m], Msg);
	}
    }

    if ( USEINSTANCES )
    {
#if ! defined WIN32 && ! defined _CONSOLE
	struct rlimit RL;

	/*  Make sure there is a largish runtime stack  */

	getrlimit(RLIMIT_STACK, &RL);

	RL.rlim_cur = Max(RL.rlim_cur, 20 * 1024 * 1024);

	if ( RL.rlim_max > 0 )	/* -1 if unlimited */
	{
	    RL.rlim_cur = Min(RL.rlim_max, RL.rlim_cur);
	}

	setrlimit(RLIMIT_STACK, &RL);
#endif

	if ( ! (F = GetFile(".data", "r")) ) Error(0, Fn, "");
	GetData(F, true, false);

	/*  Prepare the file of instances and the kd-tree index  */

	InitialiseInstances(CubistModel);

	/*  Reorder instances to improve caching  */

	CopyInstances();
	ForEach(i, 0, MaxCase)
	{
	    Free(Case[i]);
	}
	Free(Case);

	if ( PreviewModel ) printf("\nUsing instances (%d nearest neighbors)"
				   " together with rules\n\n", NN);

	IValsBase = IValsOffset;
    }
    else
    {
	ShowNN = false;
	if ( PreviewModel )
	{
	    printf("\nUsing rules alone\n\n");
	}
    }

    if ( ShowErrBounds )
    {
	/*  Estimate global error bounds for cases covered by no rules  */

	High = 0.5 * (Ceiling + Floor + (Ceiling - Floor) / (1 + 2 * EXTRAP));
	Low  = 0.5 * (Ceiling + Floor - (Ceiling - Floor) / (1 + 2 * EXTRAP));

	GlobalErrLim = 0.95 * Max(GlobalMean - Low, High - GlobalMean);
    }

    /*  Print column headings  */

    if ( ! (F = GetFile(".cases", "r")) ) Error(0, Fn, "");

    if ( LabelAtt )
    {
	printf("Case                 Given  Predicted");
	Offset += 9;
    }
    else
    {
	printf("  Case      Given  Predicted");
    }

    if ( ShowNN )
    {
	printf("%s  Dist  Nearest",
	       ( ShowErrBounds ? "               " : "  " ));

	if ( ShowErrBounds ) Offset += 13;
    }

    printf("\n%s      Value      Value",
	   ( LabelAtt ? " ID            " : "   No " ));

    if ( ShowNN )
    {
	printf("%s        Neighbor",
	       ( ShowErrBounds ? "               " : "  " ));
    }

    printf("\n\n");

    LineNo = 0;

    /*  Prepare for multi-threading */

    PrepareForSMP();

    /*  Now process the cases in file <filestem>.cases.
	This has the same format as a .data file except that the
	target value can be "?" to indicate that it is unknown.  */

    while ( true )
    {
	ForEach(t, 0, NThr-1)
	{
	    if ( Block[t] )
	    {
		WaitForFlag(Done[t]);

		CaseID++;
		PrintResult(t);

		if ( Class(Block[t]) != UNKNOWN )
		{
		    Known++;

		    if ( fabs(PredVal(Block[t]) - Class(Block[t])) <= Err[t] )
		    {
			InBounds++;
		    }
		}

		FreeCase(Block[t]);			Block[t] = Nil;
	    }
	    else
	    {
		if ( AtEOF == NThr ) break;
	    }

	    if ( ! AtEOF )
	    {
		Block[t] = GetDataRec(F, false);
		if ( Block[t] )
		{
		    ReplaceUnknowns(Block[t], Nil);

		    if ( LabelAtt )
		    {
			/*  Copy the label, up to a maximum of 14 chars  */

			if ( strlen(IgnoredVals + IValsBase) <= 14 )
			{
			    strcpy(Label[t], IgnoredVals + IValsBase);
			}
			else
			{
			    memcpy(Label[t], IgnoredVals + IValsBase, 14);
			}

			/*  Reset IValsOffset  */

			IValsOffset = IValsBase;
		    }
		}
		else
		{
		    AtEOF = 1;
		}
	    }
	    else
	    {
		Block[t] = Nil;
		AtEOF++;
	    }

	    RaiseFlag(Start[t]);
	}

	/*  Quit if the loop was interrupted  */

	if ( t < NThr ) break;
    }

    /*  Clean up threads and associated data  */

    TerminateSMP();

    if ( ShowErrBounds && Known > 0 )
    {
	printf("\n%d / %d (%g%%) cases within error bounds\n",
	       InBounds, Known, rint((100.0 * InBounds) / Known));
    }

    /*  Close the case file and free allocated memory  */
    
    fclose(F);
    
    FreeCttee(CubistModel);

    if ( USEINSTANCES )
    {
	FreeInstances();
	FreeUnlessNil(RSErrLim);
	FreeUnlessNil(RSPredVal);
    }

    FreeNamesData();
    FreeUnlessNil(PropVal);
    FreeUnlessNil(IgnoredVals);

    return 0;
}



/*************************************************************************/
/*									 */
/*	Print results for the case in BLock[t].				 */
/*									 */
/*************************************************************************/


void PrintResult(int t)
/*   -----------  */
{
    ContValue	Given, Predicted;
    char	ErrBounds[100];
    DataRec	OneCase;

    OneCase = Block[t];

    ReplaceUnknowns(OneCase, Nil);

    Given     = Class(OneCase);
    Predicted = PredVal(OneCase);

    /*  Print warning if this case has a value outside the range
	observed in the training data  */

    printf("%c", ( OutsideRange(OneCase) ? '*' : ' ' ));

    /*  Print either case label or number  */                          
    
    if ( LabelAtt )                                         
    {
	printf("%-14.14s", Label[t]);         
    }
    else
    {                                                  
	printf("%5d", CaseID);
    }

    if ( Class(OneCase) == UNKNOWN )
    {
	printf("  %9s  %9.*f", "?", Precision+1, Predicted);
    }
    else
    {
	printf("  %9.*f  %9.*f",
		    Precision, Given, Precision+1, Predicted);
    }

    if ( ShowErrBounds )
    {
	sprintf(ErrBounds, " +- %.*f", Precision+1, Err[t]);

	printf(( ShowNN ? "%-13.13s" : "%s" ), ErrBounds);
    }

    /*  See whether nearest neighbors should be shown  */

    if ( ShowNN )
    {
	ShowNearestNeighbors(Offset, &ThrEnv[t]);
    }

    printf("\n");
}



/*************************************************************************/
/*									 */
/*	Set up a block of cases, one per thread, the flags to signal	 */
/*	that a case is ready for processing and has been processed,	 */
/*	and the NN environments (if required).  Start the threads.	 */
/*									 */
/*************************************************************************/


void PrepareForSMP()
/*   -------------  */
{
    int		t;

    Thr   = Alloc(NThr, Thread);
    Block = AllocZero(NThr, DataRec);
    Err   = AllocZero(NThr, float);
    Start = Alloc(NThr, Flag);
    Done  = Alloc(NThr, Flag);

    if ( LabelAtt )
    {
	Label = Alloc(NThr, String);
    }

    if ( USEINSTANCES )
    {
	ThrEnv = Alloc(NThr, NNEnvRec);
    }

    ForEach(t, 0, NThr-1)
    {
	MakeFlag(Start[t], 1);
	MakeFlag(Done[t], 1);

	if ( ThrEnv )
	{
	    ThrEnv[t].AttMinD = Alloc(MaxAtt+1, float);
	    ThrEnv[t].WorstBest = ThrEnv[t].BestD + NN-1;
	}

	if ( LabelAtt )
	{
	    Label[t] = AllocZero(15, char);	/* truncated case label */
	}

	BeginThread(Thr[t], ProcessCase, t);
    }
}


/*************************************************************************/
/*									 */
/*	Destroy threads and associated information.			 */
/*									 */
/*************************************************************************/


void TerminateSMP()
/*   ------------  */
{
    int		t;

    ForEach(t, 0, NThr-1)
    {
	JoinThread(Thr[t]);

	DestroyFlag(Start[t]);
	DestroyFlag(Done[t]);

	if ( ThrEnv )
	{
	    Free(ThrEnv[t].AttMinD);
	}

	if ( LabelAtt ) Free(Label[t]);
    }

    Free(Thr);						Thr = Nil;
    Free(Block);					Block = Nil;
    Free(Err);						Err = Nil;
    Free(Start);					Start = Nil;
    Free(Done);						Done = Nil;
    FreeUnlessNil(ThrEnv);				ThrEnv = Nil;
    FreeUnlessNil(Label);				Label = Nil;
}



/*************************************************************************/
/*									 */
/*	Find predicted value for the cases in Block[t] as they become	 */
/*	available (signalled by Start[t]).  Signal Done[t] as each	 */
/*	case's predicted value has been determined.			 */
/*									 */
/*************************************************************************/


ThreadFn ProcessCase(int t)
/*       -----------  */
{
    while ( true )
    {
	WaitForFlag(Start[t]);

	if ( ! Block[t] )
	{
	    break;
	}

	PredVal(Block[t]) =
	    ( USEINSTANCES ?
		NNEstimate(CubistModel, Block[t], &ThrEnv[t], &Err[t]) :
		PredictValue(CubistModel, Block[t], &Err[t]) );

	RaiseFlag(Done[t]);
    }

    ThreadReturn;
}
